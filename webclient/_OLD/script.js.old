import { 
  sha512 
} from 'https://esm.sh/@noble/hashes/sha512';

import { 
  getPublicKey, 
  utils, 
  etc, 
  signAsync 
} from 'https://esm.sh/@noble/ed25519';

// Esto es obligatorio: (fallo en chrome)
etc.sha512Sync = sha512;

// Accedemos a jQuery como global, necesario para combinar module?
const $ = window.$; 


// ---
// flujo básico
// ---

// Genera y guarda el par de claves si no existen
export async function initializeUserKeys(password) {
  const existing = localStorage.getItem('dfs3_user_keys');
  if (existing) return; // Ya existen

  const salt = crypto.getRandomValues(new Uint8Array(16));

  // Deriva una clave simétrica desde la contraseña
  const keyMaterial = await getKeyMaterial(password);
  const aesKey = await deriveKey(keyMaterial, salt);

  // Genera clave privada aleatoria (32 bytes)
  const privateKey = utils.randomPrivateKey();
  const publicKey = await getPublicKey(privateKey);

  // Cifra la clave privada
  const encrypted = await encryptPrivateKey(privateKey, aesKey);

  // Almacena
  const data = {
    public_key: bufferToBase64(publicKey),
    encrypted_private_key: bufferToBase64(encrypted.ciphertext),
    salt: bufferToBase64(salt),
    iv: bufferToBase64(encrypted.iv),
    version: "1.0"
  };

  localStorage.setItem('dfs3_user_keys', JSON.stringify(data));
}


// ---
// para autenticarse
// ---

export async function getPrivateKey(password) {
  const data = JSON.parse(localStorage.getItem('dfs3_user_keys') || '{}');
  const salt = base64ToBuffer(data.salt);
  const iv = base64ToBuffer(data.iv);
  const ciphertext = base64ToBuffer(data.encrypted_private_key);

  const keyMaterial = await getKeyMaterial(password);
  const aesKey = await deriveKey(keyMaterial, salt);

  return await decryptPrivateKey(ciphertext, aesKey, iv);
}


// ---
// utilidades
// ---

async function getKeyMaterial(password) {
  const enc = new TextEncoder();
  return window.crypto.subtle.importKey(
    "raw",
    enc.encode(password),
    { name: "PBKDF2" },
    false,
    ["deriveKey"]
  );
}

async function deriveKey(keyMaterial, salt) {
  return window.crypto.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt: salt,
      iterations: 100_000,
      hash: "SHA-256"
    },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt", "decrypt"]
  );
}

async function encryptPrivateKey(data, key) {
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ciphertext = await window.crypto.subtle.encrypt(
    { name: "AES-GCM", iv: iv },
    key,
    data
  );
  return { ciphertext: new Uint8Array(ciphertext), iv };
}

async function decryptPrivateKey(ciphertext, key, iv) {
  const decrypted = await window.crypto.subtle.decrypt(
    { name: "AES-GCM", iv: iv },
    key,
    ciphertext
  );
  return new Uint8Array(decrypted);
}

function bufferToBase64(buf) {
  return btoa(String.fromCharCode(...buf));
}

function base64ToBuffer(b64) {
  return Uint8Array.from(atob(b64), c => c.charCodeAt(0));
}


// ---
// ejemplo firma de challenge
// ---

export async function signChallenge(privateKey, message) {
  const enc = new TextEncoder();
  const msgBytes = enc.encode(message);
  const signature = await signAsync(msgBytes, privateKey);

  // o signature si lo quieres binario
  return bufferToBase64(signature); 
}


// ---
// main
// ---

document.addEventListener('DOMContentLoaded', () => {

  $('#btn-init').on('click', async () => {
    const password = $('#password').val();
    await initializeUserKeys(password);
    alert('Claves generadas y almacenadas');
  });

  $('#btn-load').on('click', async () => {
    const password = $('#password').val();
    try {
      const privateKey = await getPrivateKey(password);
      $('#output').text('Clave privada cargada:' + bufferToBase64(privateKey));
    } catch (e) {
      alert('Error al descifrar la clave privada !');
    }
  });

  $('#btn-sign').on('click', async () => {
    const password = $('#password').val();
    try {
      const privateKey = await getPrivateKey(password);
      const msg = new TextEncoder().encode("challenge");
      const signature = await signAsync(msg, privateKey);
      $('#output').text('Challenge firmado: ' + bufferToBase64(signature));
    } catch (e) {
      alert('Error al firmar challenge !');
    }
  });

});
